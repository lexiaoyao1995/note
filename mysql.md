[TOC]
* [Mysql](#mysql)
  * [基础](#%E5%9F%BA%E7%A1%80)
    * [理论范式](#%E7%90%86%E8%AE%BA%E8%8C%83%E5%BC%8F)
    * [数据类型](#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
  * [数据库引擎](#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E)
    * [MyISAM](#myisam)
    * [InnoDB](#innodb)
    * [区别](#%E5%8C%BA%E5%88%AB)
  * [索引](#%E7%B4%A2%E5%BC%95)
    * [类型](#%E7%B1%BB%E5%9E%8B)
      * [联合索引 最左匹配原则](#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99)
    * [数据结构](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
      * [为什么采用B\+树](#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8b%E6%A0%91)
        * [B\+树对于B树的优势体现在查询性能上](#b%E6%A0%91%E5%AF%B9%E4%BA%8Eb%E6%A0%91%E7%9A%84%E4%BC%98%E5%8A%BF%E4%BD%93%E7%8E%B0%E5%9C%A8%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%B8%8A)
    * [索引的缺点](#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9)
    * [索引过程](#%E7%B4%A2%E5%BC%95%E8%BF%87%E7%A8%8B)
        * [Innodb的页结构](#innodb%E7%9A%84%E9%A1%B5%E7%BB%93%E6%9E%84)
        * [查询b\+树索引的流程](#%E6%9F%A5%E8%AF%A2b%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B5%81%E7%A8%8B)
  * [事务](#%E4%BA%8B%E5%8A%A1)
    * [四大特性](#%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7)
    * [事务的分类](#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%88%86%E7%B1%BB)
    * [事务隔离级别以及各个级别下的并发访问问题](#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%90%84%E4%B8%AA%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98)
    * [封锁协议](#%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE)
        * [一级封锁](#%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81)
    * [锁的分类](#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB)
        * [行锁和表锁](#%E8%A1%8C%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81)
        * [死锁](#%E6%AD%BB%E9%94%81)
    * [当前读和快照读](#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB)
    * [InnoDB可重复读级别下如何避免幻读](#innodb%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB)
    * [快照读的原理](#%E5%BF%AB%E7%85%A7%E8%AF%BB%E7%9A%84%E5%8E%9F%E7%90%86)
    * [死锁](#%E6%AD%BB%E9%94%81-1)
  * [视图](#%E8%A7%86%E5%9B%BE)
  * [存储过程](#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B)
  * [优化](#%E4%BC%98%E5%8C%96)
  * [SQL语句](#sql%E8%AF%AD%E5%8F%A5)
      * [常用](#%E5%B8%B8%E7%94%A8)


# Mysql

## 基础

### 理论范式

1、列不可再分

2、要有主键

3、所以数据直接依赖于主键，不允许简介依赖，去除传递依赖

### 数据类型

整数型，浮点型，字符串型，二级制，时间

## 数据库引擎

### MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

**场景**

1、频繁执行全表count语句

2、对数据进行增删改的频率不高，查询非常频繁

3、没有事务

### InnoDB

是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

**场景**

1、增删改查都比较频繁

2、事务

### 区别

1、MyISAM默认的是表级锁，不支持行级锁

2、InnoDB默认用的是行级所，也支持表级锁

锁分为读锁和写锁，读锁也叫共享锁（for update 可强行加排他锁），写锁也叫排他锁

innoDB在sql没有用到索引的时候，用的是表锁



## 索引

快速查询数据

### 类型

- 普通索引：仅加速查询
- 唯一索引：加速查询 + 列值唯一（可以有null）
- 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

#### 联合索引 最左匹配原则

mysql会一直向右匹配直到遇到范围查询（< > between like）就停止匹配

比如a=3 and b=4 and c>5 and d=6 如果建立（a,b,c,d）顺序的索引，d是用不到索引的，如果建立的是（abdc）的索引则可以用到，、

其中=和in可以乱序

**原因**

mysql建立复合索引，先对第一个地段进行排序，再对第二个字段排序，以此构建B+tree，所以如果在中间有范围查询就拿不到最下面的数据，就不能走索引

### 数据结构

b+树

#### 为什么采用B+树

**hash索引**

缺点

仅仅满足“=”，不能使用范围查询

遇到hash值相等的情况，性能比较低下

**二叉树**

虽然从算法逻辑上来说，二叉查找树的查询速度和比较次数都是最小的，但需要考虑磁盘io，数据库索引是存储在磁盘上的，当数据量比较大的时候，索引的大小也很大。

利用索引查询的时候，只能逐一加载每一页磁盘，这里的磁盘页对应的就是索引树的节点。

磁盘的io次数由索引的高度决定，所以需要尽量把树的高度降下来，这就是b树的作用。

**特征**：（m阶B树）

1、根节点至少有两个子女

2、每个中间节点都包含k-1个元素和k个孩子，其中m/2<=k<=m

3、每个叶子节点都包含k-1个元素，其中m/2<=k<=m

4、所有的叶子节点都位于同一层

5、每个节点中的元素从小到大排序，节点当中k-1个元素正好是k个孩子包含的元素的值域划分。

b树主要应用于文件系统以及部分数据库索引

**b+树**

b+树和b树有一些共同点，但是b+树也具备一些新特特征

1、有k个子树的中间节点包含k个元素（b树中是k-1个元素），每个元素不保存数据，只用来做索引，**所有数据都保存在叶子节点中**。

2、所有的叶子节点中包含了全部元素的信息，及**指向含这些元素记录的指针**，且叶子节点本身依关键字的大小自小到大顺序连接

3、所有的中间节点元素都同时存在于子节点，**在子节点元素中最大或是最小元**素。

还有一个特性，就是**卫星数据**的位置

**卫星数据**，指的是索引元素所指向的数据记录，比如数据库中的一行。在B树中，无论是中间节点还是叶子节点都带有卫星数据，在b+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引。

note：

在数据库的聚集索引中，叶子节点直接包含卫星数据，在非聚集索引中，叶子节点带有指向卫星数据的指针。

##### B+树对于B树的优势体现在查询性能上

1、b+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素。就是数据量相同的情况下，b+树的结构更加矮胖

2、B+树的查询速度更加稳定，b-树只要匹配到元素就可以了，无论是匹配元素是中间节点还是叶子节点，但b+树查询必须要查找到叶子节点。

3、范围查询，b+树优势明显，只需要在链表上遍历即可。

### 索引的缺点

数据量小的表不需要索引，建立会增加额外的索引开销

变更数据需要维护索引，需要更多维护成本

需要更多空间

### 索引过程

##### Innodb的页结构

页结构，是innodb存储引擎管理数据库的最小磁盘单位

innodb数据页组成部分

1、file header（文件头）

file header中，有两个指针，表示当前页的上一页和下一页，由此可以看出叶子节点是双向链表串起来的

2、page header（页头）

3、Records user Records（行记录）

行记录中，有两行虚拟的行记录来限定行记录的边界（infimum，supremum）

4、free space（空闲空间）

5、page directory（页目录）

page directory页目录中存放了记录的相对位置，有些时候这些记录指针称为Slots，槽，与其他数据库不同的是，innodb并不是每一个记录都拥有一个槽，innodb中的槽是一个稀疏目录，即一个槽中可以属于多个记录。

槽中记录按照键顺序存放，这样可以利用二分查找快速找到记录的指针。

但由于并不是没个行数据都有槽，所以二分查找的结果只是一个粗略的结果，所以innodb必须通过行记录的recorder header中的next_record来继续查找相关记录。

6、file trailer（文件结尾信息）

##### 查询b+树索引的流程

首先通过b+树索引找到叶节点，找到相应的数据页，然后将数据页加载到内存中，通过二分查找Page directory中的槽，查找出一个相对粗略的位置，然后根据槽的指针指向链表的行数据，之后在链表中依次查找。

**需要注意的是**

b+树索引不能找到具体一条记录，而是只能找到对应的页，把页从磁盘装入内存中，再通过page directory进行二分查找，同时此二分查找也可能找不到具体的行记录，只是能找到一个接近的链表中的点，再从此点开始遍历链表进行查找。

## 事务

### 四大特性

CAID

**原子性 Atomic**

要么全部成功commit，要么全部rollback

**一致性 Consistency**

rollback后的数据和原来的一致

> 原子性和一致性底层：
>
> 在操作数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo log）。然后进行数据的修改。如果出现了错误，系统利用undo log中的备份将数据恢复到事务开始之前的状态。

**隔离性 isolation**

事务和事务之间不干扰。一个事物必须与另一个事务的执行结果隔离开

> 通过数据库锁的机制实现

**持久性 durability**

执行成功。持久化数据

> 和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。

### 事务的分类

![](C:/Users/zhouguo_sx/Desktop/interview_pub/pic/%E7%88%B1%E5%A5%87%E8%89%BA20190711152902.png)

1、扁平化事务

所有的操作都在同一层次，平时使用最多的事务，不能提交或是回滚事务的某一部分，要么都成功，要么都回滚

2、带保存点的扁平事务

允许事务在执行过程中，回滚到较早的状态，而不是全部回滚，通过在事务中添加保存点，可选择事务在失败时，回滚到保存点处，

3、链事务

在事务提交时，会将上下文，隐式传递给下一个事务，当事务失败时，可以回滚到最近的事务，不过链事务只能回滚到最近一个保存点，而带保存点的事务可以回滚到任意一个保存点

4、嵌套事务

由顶层事务和子事务构成，类似于树的结构，一般顶层事务负责逻辑处理，子事务负责具体的工作，子事务可以提交，但真正的提交要等到父事务的提交，如果上层事务回滚，那么所有的子事务都会回滚

**5、分布式事务**

在分布式环境中的扁平化事务，常用的分布式事务解决方案

5.1 XA协议

XA协议是保证强一致性的刚性事务，实现方式有两段式提交和三段式提交

两段式提交需要一个事务协调者来保证第一阶段的事务参与者都完成了准备工作，如果协调者收到了所有参与者都准备好的消息，就会通知所有的事务执行第二阶段提交，但是两段式提交如果只有一个进程发生故障，也会导致系统有较长时间的阻塞。

三段式提交通过增加PreCommit阶段来减少两段式提交的系统阻塞时间

5.2 TCC

TCC是满足最终一致性的柔性事务方案，TCC采用补偿机制，核心思想是对每个操作都要注册确认和补偿操作，分为三个阶段，try阶段，主要对业务系统进行检测，即资源预留，confirm阶段进行确认提交，cancel阶段是在事务执行错误进行回滚，释放预留资源，

5.3 消息事务

将本地操作和发送消息封装在一个事务中，保证本地消息和发送消息的原子性，下游应有收到消息后执行相应的操作。

### 事务隔离级别以及各个级别下的并发访问问题

更新丢失  均可避免 包括 **read-uncommitted**

脏读  **Read-committed**及其以上

不可重复读  **repectable read**

幻读 **serializable**（串行化）

脏读：一个事务读取了另一个事务未提交的数据

不可重复读：一个事务读取数据的前后，由于另一个事务对当前行的更改，对同一行读取的数据不同 

幻读：在事务A执行了一个当前读操作，事务B在事务A的影响区域执行了插入数据的操作，此时，事务A再执行一个当前读操作，就出现了幻行。

### 封锁协议

在运用排他锁和共享锁这两种基本封锁对数据库加锁的时候，还需要有一些规定，这些规定称为封锁协议。

通常使用三级封锁协议在不同程度上解决了更新丢失，不可重复读，以及幻读，脏读问题。

##### 一级封锁

事务A在修改数据R之前需要先加排他锁，直到事务结束，可以防止更新丢失。

**二级封锁**

在一级封锁的基础上，在读数据的时候加上共享锁，直到**读**完，可防止脏读

**三级封锁**

在一级封锁的基础上，在读数据的时候加上共享锁，直到**事务**完，可防止不可重复读

### 锁的分类

按锁的粒度 分为  表级锁，行级锁，页级锁

按锁级别划分  共享锁 排他锁

按加锁方式  自动锁 显式锁

按操作划分  DML锁 DDL锁

按使用方式分  乐观锁（sql可用version或是时间戳决定） 悲观锁

##### 行锁和表锁

**行锁**

劣势：开销大；加锁慢；会出现死锁

优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强

加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：

**表锁**

优势：开销小；加锁快；无死锁

劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低

加锁的方式：自动加锁。查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。也可以显示加锁：

##### 死锁

**如何发现死锁**

查看innodb日志

show engine innodb status \G; 

**情况一**

​	一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。

> 解决方法：
>
> 这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进 行处理，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。

**情况二**

用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A 有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁比较隐蔽，但在稍大点的项 目中经常发生。如在某项目中，页面上的按钮点击后，没有使按钮立刻失效，使得用户会多次快速点击同一按钮，这样同一段代码对数据库同一条记录进行多次操 作，很容易就出现这种死锁的情况。

> 解决方法：
>
> 1、对于按钮等控件，点击后使其立刻失效，不让用户重复点击，避免对同时对同一条记录操作。
> 2、使用乐观锁进行控制。乐观锁大多是基于数据版本（Version）记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是 通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数 据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。乐观锁机制避免了长事务中的数据 库加锁开销（用户A和用户B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。Hibernate 在其数据访问引擎中内置了乐观锁实现。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户更新操作不受我们系统的控制，因此可能会造 成脏数据被更新到数据库中。
> 3、使用悲观锁进行控制。悲观锁大多数情况下依靠数据库的锁机制实现，如Oracle的Select … for update语句，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。如一个金融系统， 当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户账户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读 出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对成百上千个并发，这 样的情况将导致灾难性的后果。所以，采用悲观锁进行控制时一定要考虑清楚。

**情况三**

如果在事务中执行了一条不满足条件的update语句，则执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情 况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。

> 解决方法：
>
> SQL语句中不要使用太复杂的关联多表的查询；使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。



### 当前读和快照读

当前读：

select ..lock in share mode

select...for update

update

delete

insert

快照读

不加锁的非阻塞读，select（有可能会读到历史数据）

### InnoDB可重复读级别下如何避免幻读

**1、使用了快照读（非阻塞读），即伪MVCC**

mvcc是Multi-Version Concurrency Control，多版本并发控制 ，为什么是伪MVCC呢，因为mysql并没有把所有的版本记录下来，而是在undo日志里记录当前活跃的事务。

**2、实际上是next-key（行锁+gap锁）**

gap使用时机：

用在非唯一索引，或是不走索引，或是没有全部命中的主键索引，的当前读中

### 快照读的原理

1、利用了数据行的隐藏列  DB_TRX_ID  DB_ROLL_PTR  DB_ROW_ID

2、undo日志 undolog：对数据产生了变更操作时，就会产生undolog，存储的是历史数据

insert undolog

update undolog

3、read view

在RR级别下，第一条快照读，会创建一条快照，read view，将系统中其他的活跃的事务记录起来，以后再调用快照读时，还是同一条read view

### 死锁



## 视图

视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。

对视图的操作和对普通表的操作一样。

视图具有如下好处：

- 简化复杂的 SQL 操作，比如复杂的连接；
- 只使用实际表的一部分数据；
- 通过只给用户访问视图的权限，保证数据的安全性；
- 更改数据格式和表示。

## 存储过程

存储过程可以看成是对一系列 SQL 操作的批处理。

使用存储过程的好处：

- 代码封装，保证了一定的安全性；
- 代码复用；
- 由于是预先编译，因此具有很高的性能。

存储过程思想就是sql语言层面的封装和重用

## 优化

![](/pic/%E7%88%B1%E5%A5%87%E8%89%BA20190711154848.png)

![](/pic/%E7%88%B1%E5%A5%87%E8%89%BA20190711155001.png)

## SQL语句

#### 常用

group by

having

count sum max min avg

**group by** 

1、满足“select 子句中的列名必须为分组列或是列函数”

2、列函数对于group by子句定义的每个组各返回一个结果

**having**

1、通常和group by子句一起使用

2、where过滤行，having过滤组

3、出现在同一sql的顺序，where>group by>having