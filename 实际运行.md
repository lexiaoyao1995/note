* [Spring](#spring)
    * [@PostConstruct](#postconstruct)
* [JavaSE](#javase)
  * [时间处理](#%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86)
  * [list和数组的相互转换](#list%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2)
      * [list  \-&gt; array](#list----array)
      * [array\-&gt; list](#array--list)

# Spring

### @PostConstruct

<https://www.jianshu.com/p/98cf7d8b9ec3>

~~~java
    public Class AAA{   
        @Autowired   
        private BBB b;    
        
        public AAA() {       
            System.out.println("此时b还未被注入: b = " + b);   
        }
           
        @PostConstruct   
        private void init () {       
            System.out.println("@PostConstruct将在依赖注入完成后被自动调用: b = " + b);
        }
    }
~~~

# JavaSE

## 时间处理

~~~java
Date date = new Date(0);//date可以传入时间戳构造


Calendar instance = Calendar.getInstance();//Calender可以方便地获取Date里的时间
instance.setTime(new Date());
int year = instance.get(Calendar.YEAR);
int date = instance.get(Calendar.DATE);


//获取指定时间的Date类型
DateFormat fmtDateTime = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String strDate = "1999-08-11 09:14:14";
Date date = fmtDateTime.parse(strDate);
~~~

## list和数组的相互转换

#### list  -> array

~~~java
//list 转数组
ArrayList<String> list=new ArrayList<String>(){
    {
        add("asd");
        add("aasd");
        add("asssd");

    }
};
String[] strings = new String[list.size()];
list.toArray(strings);
System.out.println(Arrays.toString(strings));
~~~

#### array-> list

~~~java
String[] s = {"a","b","c"};
List<String> strings = Arrays.asList(s);
System.out.println(strings);
~~~

# 跨域问题

CORS全称Cross-Origin Resource Sharing，意为跨域资源共享。当一个资源去访问另一个不同域名或者同域名不同端口的资源时，就会发出跨域请求。如果此时另一个资源不允许其进行跨域资源访问，那么访问的那个资源就会遇到跨域问题。

### 解决方案

覆盖默认的CorsFilter来解决该问题

~~~java
package com.macro.mall.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

/**
 * 全局跨域配置
 * Created by macro on 2019/7/27.
 */
@Configuration
public class GlobalCorsConfig {

    /**
     * 允许跨域调用的过滤器
     */
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        //允许所有域名进行跨域调用
        config.addAllowedOrigin("*");
        //允许跨越发送cookie
        config.setAllowCredentials(true);
        //放行全部原始头信息
        config.addAllowedHeader("*");
        //允许所有请求方法跨域调用
        config.addAllowedMethod("*");
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}


~~~

# 降级、熔断、限流

### 降级

降级也就是服务降级，当我们的服务器压力剧增为了**保证核心功能的可用性** ，而**选择性的降低一些功能的可用性，或者直接关闭该功能**。这就是典型的**丢车保帅**了。 就比如贴吧类型的网站，当服务器吃不消的时候，可以选择把发帖功能关闭，注册功能关闭，改密码，改头像这些都关了，为了确保登录和浏览帖子这种核心的功能。

一般而言都会建立一个独立的降级系统，可以灵活且批量的配置服务器的降级功能。当然也有用代码自动降级的，例如接口超时降级、失败重试多次降级等。具体失败几次，超时设置多久，由你们的业务等其他因素决定。开个小会，定个值，扔线上去看看情况。根据情况再调优。

### 熔断

**降级一般而言指的是我们自身的系统出现了故障而降级。而熔断一般是指依赖的外部接口出现故障的情况断绝和外部接口的关系。**

例如你的A服务里面的一个功能依赖B服务，这时候B服务出问题了，返回的很慢。这种情况可能会因为这么一个功能而拖慢了A服务里面的所有功能，因此我们这时候就需要熔断！即当发现A要调用这B时就直接返回错误(或者返回其他默认值啊啥的)，就不去请求B了。我这还是举了两个服务的调用，有些那真的是一环扣一环，出问题不熔断，那真的是会雪崩。

当然也有人认为熔断不就是降级的一种的，我觉得你非要说熔断也属于一种降级我也没法反驳，但是它们本质上的突出点和想表达的意思还是有一些不同的。

### 限流

上面说的两个算是请求过来我们都受理了，这个限流就更狠了，直接跟请求说对不起再见！也就是系统规定了多少承受能力，只允许这么些请求能过来，其他的请求就说再见了。

一般限制的指标有：**请求总量或某段时间内请求总量**。