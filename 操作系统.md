* [操作系统](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)
  * [内存分配策略](#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5)
  * [进程与线程](#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B)
    * [区别和联系](#%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB)
    * [线程调度](#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6)
    * [线程切换步骤](#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%AD%A5%E9%AA%A4)
    * [linux下IPC（进程间通信）](#linux%E4%B8%8Bipc%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1)
    * [协程](#%E5%8D%8F%E7%A8%8B)
    * [为什么线程调度比进程调度开销小](#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%AF%94%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%BC%80%E9%94%80%E5%B0%8F)
      * [进程与线程的差异](#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%BC%82)
      * [任务调度的开销](#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9A%84%E5%BC%80%E9%94%80)
  * [用户态和内核态](#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81)
    * [特权级](#%E7%89%B9%E6%9D%83%E7%BA%A7)
    * [用户态和内核态的概念：](#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5)
    * [用户态和内核态的切换](#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2)
      * [（1）系统调用](#1%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8)
      * [（2）异常](#2%E5%BC%82%E5%B8%B8)
      * [（3）外围设备的中断](#3%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87%E7%9A%84%E4%B8%AD%E6%96%AD)
    * [用户态到内核态具体的切换步骤：](#%E7%94%A8%E6%88%B7%E6%80%81%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E5%85%B7%E4%BD%93%E7%9A%84%E5%88%87%E6%8D%A2%E6%AD%A5%E9%AA%A4)

# 操作系统

## 内存分配策略

静态存储 ：编译时确定每个数据目标在运行时的存储空间需求 

要求代码中不允许有可变数据存在，或是递归存在

栈式存储：数据区需求在编译时未知，运行时确定

堆式存储：数据区在编译时和运行时都无法确定

## 进程与线程

### 区别和联系

进程是资源分配的最小单位，线程是程序执行的最小单位

进程使用独立的数据空间，线程共享进程的数据空间

### 进程之间通信

进程之间共享数据 通过共享内存的方式

> **共享内存**这个通信方式就可以很好着解决拷贝所消耗的时间了。系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。
>
> 共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的**线程安全**问题。如何解决这个问题？这个时候我们的**信号量**就上场了。
>
> 信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问**内存1**的时候，我们就把信号量的值设为 0，然后进程b 也要来访问**内存1**的时候，看到信号量的值为 0 就知道已经有进程在访问**内存1**了，这个时候进程 b 就会访问不了**内存1**。所以说，信号量也是进程之间的一种通信方式。

进程之间交换数据 通过socket方式

> 这个就是我们一直在用的进程间的通信方式了，如我们的微信APP跟微信服务器通信，其实就是使用的Socket套接字进行通信的。

### 线程调度

线程调度算法

时间片轮转调度，先来先服务调度，优先级调度，高响应比优先调度

### 线程切换步骤

线程上下文切换，线程切换代价

> 对于单核CPU来说（对于多核CPU，此处就理解为一个核），CPU在一个时刻只能运行一个线程，当在运行一个线程的过程中转去运行另外一个线程，这个叫做线程上下文切换（对于进程也是类似）。

> 线程切换时需要知道在这之前当前线程已经执行到哪条指令了，所以需要记录程序计数器的值，另外比如说线程正在进行某个计算的时候被挂起了，那么下次继续执行的时候需要知道之前挂起时变量的值时多少，因此需要记录CPU寄存器的状态。所以一般来说，线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。

### linux下IPC（进程间通信）

进程间数据共享的场景，使用共享内存

进程间数据交换的场景，使用UnixSocket

### 协程

更轻量化，是在用户态进行调度，切换的代价比线程切换低很多

现在常用的工具是Quasar

### fork

​    一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。
​    一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。

fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：
    1）在父进程中，fork返回新创建子进程的进程ID；
    2）在子进程中，fork返回0；
    3）如果出现错误，fork返回一个负值；

​    在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。

### 为什么线程调度比进程调度开销小

#### 进程与线程的差异

从概念上来讲，线程是进程的一部分，只是任务调度相关的部分，所以我们才说，“线程是调度的最小单位”。进程拥有着资源，这些资源不属于某一个特定线程，因为所有线程共享进程拥有的资源，所以我们才说，“进程是资源分配的最小单位”。需要特别说明的是，Linux在线程与进程的实现上与概念上有少许差别，这个等下再讨论。

所以，我们fork一个新的进程时，实际上“伴生”了一个线程，而这个唯一的线程，实际上代表了这个进程参与到任务调度。在执行的过程中，进程通过pthread_create创建了更多的线程，例如上图中的线程2，线程n。此时，不管线程1，线程2，还是线程n，他们都代表了进程进行任务调度。

既然我们知道了进程与线程有什么关系，那么实际的linux内核是怎么实现进程与线程的呢？

在linux中，不管进程还是线程，都用struct task_struct描述。

~~~shell
struct task_struct {
	...
	struct mm_struct *mm; /*内存资源*/
	...
}
~~~

既然都是用struct task_struct描述，那么进程和线程的关系怎么体现？资源指针！例如上面代码块描述的结构成员struct mm_struct *mm，这是一个指针，指向实际的内存资源。同一个进程内的所有线程，他们都使用相同的资源，只需要把对应的资源指针指向相同的地址。

Linux内核就好像淡化了“线程”的概念，每一个线程描述都是struct task_struct，他们都是一个独立的“进程”，都有着自己的进程号，都参与任务调度，只不过指向相同的进程资源。

#### 任务调度的开销
既然我们知道了进程和线程在linux实现上的关系，我们再来分析，为什么说线程调度比进程调度开销更小？

或许你有这样的疑问，既然在linux实现上，线程都是独立的struct task_struct，都参与任务调度，那这里说的线程调度和进程调度怎么区分？

我们不妨这样定义：

**线程调度：使用相同资源的`struct task_struct`之间的调度**
**进程调度：使用不同资源的`struct task_struct`之间的调度**

基于这样的定义，为了方便分析问题，我们回顾一下任务调度的开销主要有什么？

1. **CPU执行任务调度的开销，主要是进程上下文切换的开销**
2. **任务调度后，CPU Cache/TLB不命中，导致缺页中断的开销**

对于第1点的开销，不管是进程调度还是线程调度都是必须的，所以，两者的差异体现在第2点。

再看回我们对“进程调度”和“线程调度”的定义，有没觉得灵光一闪？既然线程调度的struct task_struct都使用相同的资源，是不是就意味着，我即使切换到了其他的线程，**CPU Cache/TLB命中的概率会高很多**？相反，进程调度使用的是不同的资源，每次换了个进程，就意味着原有的Cache就不适用了，没命中，就触发更多的缺页中断，开销自然就更多。

## 用户态和内核态

### 特权级

对于任何操作系统来说，创建一个进程是核心功能。创建进程要做很多工作，会消耗很多物理资源。比如分配物理内存，父子进程拷贝信息，拷贝设置页目录页表等等，这些工作得由特定的进程去做，所以就有了特权级别的概念。最关键的工作必须交给特权级最高的进程去执行，这样可以做到集中管理，减少有限资源的访问和使用冲突。inter x86架构的cpu一共有四个级别，0-3级，0级特权级最高，3级特权级最低。

### 用户态和内核态的概念：

当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的地址空间，包括代码和数据；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。

用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。进程会切换到Ring0，然后进入3G-4G中的内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。这说的保护模式是指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。

### 用户态和内核态的切换

当在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态。

用户态切换到内核态的3种方式

#### （1）系统调用

这是用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。例如fork（）就是执行了一个创建新进程的系统调用。系统调用的机制和新是使用了操作系统为用户特别开放的一个中断来实现，如Linux的int 80h中断。

#### （2）异常

当cpu在执行运行在用户态下的程序时，发生了一些没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。

#### （3）外围设备的中断

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令而转到与中断信号对应的处理程序去执行，如果前面执行的指令时用户态下的程序，那么转换的过程自然就会是 由用户态到内核态的切换。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。

这三种方式是系统在运行时由用户态切换到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。从触发方式上看，切换方式都不一样，但从最终实际完成由用户态到内核态的切换操作来看，步骤有事一样的，都相当于执行了一个中断响应的过程。系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本一致。

### 用户态到内核态具体的切换步骤：

（1）从当前进程的描述符中提取其内核栈的ss0及esp0信息。

（2）使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。

（3）将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。

