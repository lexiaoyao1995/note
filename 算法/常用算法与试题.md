# 常用算法

### 雪花算法

生产全局唯一id

##### UUID

UUID是通用唯一识别码 (Universally Unique Identifier)，在其他语言中也叫GUID，可以生成一个长度32位的全局唯一识别码。

![](C:/Users/zhouguo_sx/Desktop/interview_pub/pic/%E7%88%B1%E5%A5%87%E8%89%BA20190708135417.png)

为什么无序的UUID会导致入库性能变差呢？

这就涉及到 **B+树索引的分裂**：

> 众所周知，关系型数据库的索引大都是B+树的结构，拿ID字段来举例，索引树的每一个节点都存储着若干个ID。
>
> 如果我们的ID按递增的顺序来插入，比如陆续插入8，9，10，新的ID都只会插入到最后一个节点当中。当最后一个节点满了，会裂变出新的节点。这样的插入是性能比较高的插入，因为这样节点的分裂次数最少，而且充分利用了每一个节点的空间。
>
> 但是，如果我们的插入完全无序，不但会导致一些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。

#### 数据库自增主键

![](C:/Users/zhouguo_sx/Desktop/interview_pub/pic/%E7%88%B1%E5%A5%87%E8%89%BA20190708135626.png)

##### 雪花算法

![](C:/Users/zhouguo_sx/Desktop/interview_pub/pic/%E7%88%B1%E5%A5%87%E8%89%BA20190708135650.png)

SnowFlake所生成的ID一共分成四部分：

1.第一位

占用1bit，其值始终是0，没有实际作用。

2.时间戳

占用41bit，精确到毫秒，总共可以容纳约140年的时间。

3.工作机器id

占用10bit，其中高位5bit是数据中心ID（datacenterId），低位5bit是工作节点ID（workerId），做多可以容纳1024个节点。

4.序列号

占用12bit，这个值在同一毫秒同一节点上从0开始不断累加，最多可以累加到4095。

**SnowFlake算法的优点：**

1.生成ID时不依赖于DB，完全在内存生成，高性能高可用。

2.ID呈趋势递增，后续插入索引树的时候性能较好。

**SnowFlake算法的缺点：**

依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。

### 辗转相除法

```java
public static int gcd(int m, int n) 
{
     
while (true) 
    {
     
if ((m = m % n) == 0)
         
return n;
         
if ((n = n % m) == 0)
             
return m;
 
}
 
}
```

### 二分查找

```java
private static boolean Binarysearch(int[] a, int target) {

		int low = 0;
		int high = a.length - 1;
		int middle;
		while (low <= high) {
			middle = (low + high) / 2;
			if (a[middle] == target) {
				return true;
			} else if (a[middle] > target) {
				high = middle - 1;
			} else {
				low = middle + 1;
			}
		}
		return false;

	}
```

### 背包问题

```java
package demo;

import javax.swing.plaf.basic.BasicInternalFrameTitlePane.MaximizeAction;

public class MainTest {

	public static void main(String[] args) {

		int m = 10;
		int n = 3;
		int[] w = { 0, 3, 4, 5 };
		int[] p = { 0, 4, 5, 6 };

		int[][] c = solution(m, n, w, p);
		for (int i = 0; i < c.length; i++) {
			for (int j = 0; j < c[0].length; j++) {
				System.out.print(c[i][j] + "\t");
			}
			System.out.println();
		}

	}

	private static int[][] solution(int m, int n, int[] w, int[] p) {
		// TODO Auto-generated method stub
		int[][] c = new int[n + 1][m + 1];
		for (int i = 0; i < n + 1; i++) {
			c[i][0] = 0;
		}
		for (int j = 0; j < m + 1; j++) {
			c[0][j] = 0;
		}

		for (int i = 1; i < n + 1; i++) {
			for (int j = 1; j < m + 1; j++) {
				if (w[i] > j) {
					c[i][j] = c[i - 1][j];
				} else {
					c[i][j] = max(c[i - 1][j], c[i - 1][j - w[i]] + p[i]);
				}
			}
		}
		return c;
	}

	private static int max(int i, int j) {
		return i >= j ? i : j;
	}

}
```

### 最长上升子序列

```java
package demo;

public class MainTest {

	public static void main(String[] args) {

		int[] a = { 2, 7, 1, 5, 6, 4, 3, 8, 9 };

		int n = getLIS(a);

		System.out.println(n);

	}

	private static int getLIS(int[] a) {
		int[] d = new int[a.length];
		for (int i = 0; i < a.length; i++) {
			//初始化为1
			d[i] = 1;
			//遍历i之前比a[i]小的数，并以最大值更新d
			for (int j = 0; j < i; j++) {
				if (a[j] <= a[i] && d[i] <= d[j] + 1) {
					d[i] = d[j] + 1;
				}
			}
		}

		return d[d.length - 1];
	}

}
```

### 汉诺塔

```java
package demo;
//移动次数为2的n次方减1
public class Hanoi {

	public static void detail(int n,char x,char y,char z) {
		
		if (n==0) {
			return;
		}else {
			detail(n-1, x, z, y);
			System.out.println(x+"->"+y);
			detail(n-1, z, y, x);
		}
		
	}
	
	public static void main(String[] args) {
		char x= 'x',y='y',z='z';
		detail(3, x, y, z);
	}
	
}
```

### 键盘输入格式

```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] sa = br.readLine().split(" ");
		int[] arrays = new int[sa.length];
		int k = 0;
		for (String string : sa) {
			arrays[k++] = Integer.parseInt(string);
		}
		int ans = 0;
		for (int i : arrays) {
			ans += i;
		}
		System.out.println(ans);
```

### 全排列

```java
package demo5;

public class Test {

	public static void main(String[] args) {

		int[] a = { 1, 2, 3 };

		fullSort(a, 0, a.length - 1);

	}

	private static void fullSort(int[] a, int start, int end) {
		// TODO Auto-generated method stub
		if (start == end) {
			for (int i : a) {
				System.out.print(i);
			}
			System.out.println();
			return;
		}
		for (int i = start; i <= end; i++) {
			swap(a, i, start);
			fullSort(a, start + 1, end);
			swap(a, i, start);
		}

	}

	private static void swap(int[] a, int i, int j) {
		// TODO Auto-generated method stub
		int t = a[i];
		a[i] = a[j];
		a[j] = t;
	}

}
```

### 死锁

```java
package demo5;

public class Test {

	public static String obj1 = "obj1";

	public static String obj2 = "obj2";

	public static void main(String[] args) {

		Thread a = new Thread(new Runnable() {
			@Override
			public void run() {
				// TODO Auto-generated method stub
				System.out.println("a running");
				while (true) {
					synchronized (obj1) {
						System.out.println("get obj1");
						try {
							Thread.sleep(3000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						synchronized (obj2) {
							System.out.println("get obj2");
						}
					}
				}
			}
		});

		Thread b = new Thread(new Runnable() {

			@Override
			public void run() {
				// TODO Auto-generated method stub
				System.out.println("b running");
				while (true) {
					synchronized (obj2) {
						System.out.println("get obj2");
						try {
							Thread.sleep(3000);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						synchronized (obj1) {
							System.out.println("get obj1");
						}
					}
				}
			}
		});

		a.start();
		b.start();

	}
}
```

### 字符匹配问题

![](../pic/爱奇艺20190704202819.png)

##### 单模匹配

![](../pic/爱奇艺20190705144648.png)

# 算法题

### 去重

1. set

2. map

3. 先排序，再去重

4. 遍历

   新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf为-1）就加入该新数组中； 利用数组的indexOf下标属性来查询。

5.     public static void searchRepeatIndex(int[] arr){
              for (int i = 0; i < arr.length-1; i++) {
                  for (int j = i+1; j < arr.length; j++) {
                      if (arr[i]==arr[j]) {
                          System.out.println("第"+(i+1)+"个元素重复了");
                          break;//去掉这句可以查找重复次数
                      }
                  }
              }
          }

### 最大连续子序列的和

1、采用枚举法

一个长度为n的数组，一共有n(n+1)/2个子数组，时间复杂度O(n2)

```java
    /**
     * i 遍历 起始坐标
     * j 遍历 子数组长度
     * @param array
     * @return
     */
    private static int countMax(int[] array) {
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j <= array.length - i; j++) {
                int count = count(array, i, j);
                max = count > max ? count : max;
            }
        }
        return max;
    }

    /**
     *
     * @param array
     * @param index 计算的起始位置
     * @param length 计算的数组长度
     * @return
     */
    private static int count(int[] array, int index, int length) {
        int sum = 0;
        for (int i = index; i < index + length; i++) {
            sum += array[i];
        }
        return sum;
    }

```

2、分析规律

从头到尾依次逐个累加实例数组中的每个数字；

首先加上第一个数字，从第二个数字开始开始累加，依次将累加和保存到一个临时变量中

如果当前累加和小于0，那抛弃前面的子数组和，从下一个数字开始重新累加。

同步更新最大值。

```java
    public static int maxSunArray(int[] array) {
        int max = array[0];
        int temp = array[0];
        for (int i = 1; i < array.length; i++) {
            if (temp < 0) {
                temp = array[i];
            } else {
                temp += array[i];
            }
            if (temp > max) max = temp;
        }
        return max;
    }
```

### 最小的K个数

1、排序

```java
    private static int[] smallestNum(int[] array, int n) {
        Arrays.sort(array);
        int[] ans = Arrays.copyOf(array, n);
        return ans;
    }
```

2、使用最大堆，如果容器中已有的数字少于k个，则直接放入容器；如果容器中已有k个数字，也就是容器已满，此时我们不能再插入新的数字而只能替代已有的数字，找出这已有k个数字中的最大值。

3.采用快排的思路

 只需找到第k大的数，不必把所有的数排好序。我们借助快[速排序](http://blog.csdn.net/zhangxiangdavaid/article/details/25436609)中partition过程，一般情况下，在把所有数都排好序前，就可以找到第k大的数。我们依据的逻辑是，经过一次partition后，数组被pivot分成左右两部分：S左、S右。当S左的元素个数|S左|等于k-1时，pivot即是所找的数；当|S左|小于k-1，所找的数位于S右中；当|S左|>k-1，所找的数位于S左中。显然，后两种情况都会使搜索空间缩小。

算法的时间复杂度为：O(N)--详情参考算法导论。

```java
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9};
//        int i = quickSort(array, 0, array.length - 1);
        int k = find(array, 0, array.length - 1, 6);
        System.out.println(Arrays.toString(array));
        System.out.println(k);
    }

    private static int find(int[] array, int low, int high, int k) {
        int m = quickSort(array, low, high);
        if (k == m - low + 1) return array[m];
        else if (k < m - low + 1) return find(array, low, m - 1, k);
        else return find(array, m + 1, high, k - (m - low + 1));
    }

    //返回的是交换点的位置
    private static int quickSort(int[] array, int low, int high) {
        int i = low;
        int j = high;
        int stand = array[low];
        while (i < j) {
            while (i < j) {
                if (array[j] < stand) break;
                j--;
            }
            while (i < j) {
                if (array[i] > stand) break;
                i++;
            }
            if (i < j) {
                int t = array[i];
                array[i] = array[j];
                array[j] = t;
            }
        }
        array[low] = array[i];
        array[i] = stand;
        return i;
    }
}
```



### 找寻确实的整数

**题目**：一个无序数组里有99个不重复正整数，范围从1到100，唯独缺少一个整数。如何找出这个缺失的整数？

**解法一：**

创建一个HashMap，以1到100为键，值都是0 。然后遍历整个数组，每读到一个整数，就找到HashMap当中对应的键，让其值加一。

由于数组中缺少一个整数，最终一定有99个键值等于1, 剩下一个键值等于0。遍历修改后的HashMap，找到这个值为0的键。

假设数组长度是N，那么该解法的时间复杂度是O（1），空间复杂度是O（N）。

**解法二：**

先把数组元素进行排序，然后遍历数组，要么有其中两个相邻元素之间的差不是1，要么缺失的整数是1或100。

假设数组长度是N，如果用时间复杂度为O（N*LogN）的排序算法进行排序，那么该解法的时间复杂度是O（N*LogN），空间复杂度是O（1）。

**解法三：**

很简单也很高效的方法，先算出1+2+3....+100的合，然后依次减去数组里的元素，最后得到的差，就是唯一缺失的整数。

假设数组长度是N，那么该解法的时间复杂度是O（N），空间复杂度是O（1）。

**题目扩展**：一个无序数组里有若干个正整数，范围从1到100，其中99个整数都出现了偶数次，只有一个整数出现了奇数次（比如1,1,2,2,3,3,4,5,5），如何找到这个出现奇数次的整数？

**解法：**

遍历整个数组，依次做异或运算。由于异或在位运算时相同为0，不同为1，因此所有出现偶数次的整数都会相互抵消变成0，只有唯一出现奇数次的整数会被留下。

假设数组长度N，那么该解法的时间复杂度是O（N），空间复杂度是O（1）。

**题目第二次扩展**：一个无序数组里有若干个正整数，范围从1到100，其中98个整数都出现了偶数次，只有**两个**整数出现了奇数次（比如1,1,2,2,3,4,5,5），如何找到这个出现奇数次的整数？

**解法：**

遍历整个数组，依次做异或运算。由于数组存在两个出现奇数次的整数，所以最终异或的结果，等同于这两个整数的异或结果。这个结果中，至少会有一个二进制位是1（如果都是0，说明两个数相等，和题目不符）。

举个例子，如果最终异或的结果是5，转换成二进制是00000101。此时我们可以选择任意一个是1的二进制位来分析，比如末位。把两个奇数次出现的整数命名为A和B，如果末位是1，说明A和B转为二进制的末位不同，必定其中一个整数的末位是1，另一个整数的末位是0。

根据这个结论，我们可以把原数组按照二进制的末位不同，分成两部分，一部分的末位是1，一部分的末位是0。由于A和B的末位不同，所以A在其中一部分，B在其中一部分，绝不会出现A和B在同一部分，另一部分没有的情况。

这样一来就简单了，我们的问题又回归到了上一题的情况，按照原先的异或解法，从每一部分中找出唯一的奇数次整数即可。

假设数组长度是N，那么该解法的时间复杂度是O（N）。把数组分成两部分，并不需要借助额外存储空间，完全可以在按二进制位分组的同时来做异或运算，所以空间复杂度仍然是O（1）。

### 判断一个数是否是2的乘方

**题目：**实现一个方法，判断一个正整数是否是2的乘方（比如16是2的4次方，返回True；18不是2的乘方，返回False）。要求性能尽可能高。

**解法一：**

创建一个中间变量Temp，初始值是1。然后进入一个循环，循环中每次让Temp和目标整数比较，如果相等，则说明目标整数是2的乘方；如果不相等，则让Temp增大一倍，继续循环比较。当Temp大于目标整数时，说明目标整数不是2的乘方。

如果目标整数的大小是N，则此方法的时间复杂度是O（LogN）。

**解法二：**

非常有趣也非常简单的解法。因为2的乘方都符合一个规律，即 N&N-1 等于 0，所以直接用这个规律判断即可。该算法时间复杂度是O（1）。

### 判断一个链表是否有环

**方法一：**首先从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就从头节点重新遍历新节点之前的所有节点，用新节点ID和此节点之前所有节点ID依次作比较。如果发现新节点之前的所有节点当中存在相同节点ID，则说明该节点被遍历过两次，链表有环；如果之前的所有节点当中不存在相同的节点，就继续遍历下一个新节点，继续重复刚才的操作。

例如这样的链表：A->B->C->D->B->C->D， 当遍历到节点D的时候，我们需要比较的是之前的节点A、B、C，不存在相同节点。这时候要遍历的下一个新节点是B，B之前的节点A、B、C、D中恰好也存在B，因此B出现了两次，判断出链表有环。

假设从链表头节点到入环点的距离是D，链表的环长是S。那么算法的时间复杂度是0+1+2+3+....+(D+S-1) = (D+S-1)*(D+S)/2 ， 可以简单地理解成 O(N*N)。而此算法没有创建额外存储空间，空间复杂度可以简单地理解成为O(1)。

**方法二：**首先创建一个以节点ID为键的HashSet集合，用来存储曾经遍历过的节点。然后同样是从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就用新节点和HashSet集合当中存储的节点作比较，如果发现HashSet当中存在相同节点ID，则说明链表有环，如果HashSet当中不存在相同的节点ID，就把这个新节点ID存入HashSet，之后进入下一节点，继续重复刚才的操作。

这个方法在流程上和方法一类似，本质的区别是使用了HashSet作为额外的缓存。

假设从链表头节点到入环点的距离是D，链表的环长是S。而每一次HashSet查找元素的时间复杂度是O(1), 所以总体的时间复杂度是1*(D+S)=D+S，可以简单理解为O(N)。而算法的空间复杂度还是D+S-1，可以简单地理解成O(N)。

**方法三：**首先创建两个指针1和2（在java里就是两个对象引用），同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针1每次向下移动一个节点，让指针2每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环。

例如链表A->B->C->D->B->C->D，两个指针最初都指向节点A，进入第一轮循环，指针1移动到了节点B，指针2移动到了C。第二轮循环，指针1移动到了节点C，指针2移动到了节点B。第三轮循环，指针1移动到了节点D，指针2移动到了节点D，此时两指针指向同一节点，判断出链表有环。

此方法也可以用一个更生动的例子来形容：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过，原因很简单，因为跑道是环形的。

##### 如何找到环的入口点

思路： 
如果单链表有环，当slow指针和fast指针相遇时，slow指针还没有遍历完链表，而fast指针已经在环内循环n（n>=1）圈了，假设此时slow指针走了s步，fast指针走了2s步，r为fast在环内转了一圈的步数，a为从链表头到入口点的步数，b为从入口点到相遇点的步数，c为从相遇点再走c步到达入口点，L为整个链表的长度。

**综上可得**：从链表头到环入口点等于(n - 1)循环内环 + 相遇点到环入口点，于是在链表头和环入口点分别设置一个指针，同时出发，每次各走一步，它们必定会相遇，且第一次相遇的点就是环入口点。

```java
public static Node findLoopPort(Node head) {
        Node slow = head;
        Node fast = head;
        //先判断该链表是否有环
        while(fast != null && fast.next !=null) {
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) {
                break;
            }
        }
        if(fast == null || fast.next == null) {
            return null;
        }
        //如果链表有环，则将slow设置指向链表头，此时fast指向相遇点，然后同时开始移动，直到两个指针相遇
        slow = head;
        while(slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
```



### 最小栈的实现

实现一个栈，带有出栈（pop），入栈（push），取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）。

![](C:/Users/zhouguo_sx/Desktop/interview_pub/pic/%E7%88%B1%E5%A5%87%E8%89%BA20190708141813.png)

> **解法：**
>
> 1.设原有的栈叫做栈A，此时创建一个额外的栈B，用于辅助原栈A。
>
> 2.当第一个元素进入栈A的时候，让新元素的下标进入栈B。这个唯一的元素是栈A的当前最小值。（考虑到栈中元素可能不是类对象，所以B栈存储的是A栈元素的下标）
>
> 3.每当新元素进入栈A时，比较新元素和栈A当前最小值的大小，如果小于栈A当前最小值，则让新元素的下标进入栈B，此时栈B的栈顶元素就是栈A当前最小值的下标。
>
> 4.每当栈A有元素出栈时，如果出栈元素是栈A当前最小值，则让栈B的栈顶元素也出栈。此时栈B余下的栈顶元素所指向的，是栈A当中原本第二小的元素，代替刚才的出栈元素成为了栈A的当前最小值。（备胎转正）
>
> 5.当调用getMin方法的时候，直接返回栈B的栈顶所指向的栈A对应元素即可。

### 无序数组排序后的最大相邻差值

**题目**：有一个无序整型数组，如何求出这个数组排序后的任意两个相邻元素的最大差值？要求时间和空间复杂度尽可能低。（例如：无序数组 2,3,1,4,6，排序后是1,2,3,4,6，最大差值是6-4=2）

**解法一：**

用一种较快的稳定排序算法（比如归并算法，时间复杂度N*logN）给原数组排序，然后遍历排好序的数组，每两个相邻元素求差，最终得到最大差值。

该解法的时间复杂度是O（N*logN），在不改变原数组的情况下，空间复杂度是O（N）。

**解法二：**

1.利用计数排序的思想，先求出原数组的最大值Max与最小值Min的区间长度k（k=Max-Min+1）。

2.创建一个长度为k的新数组Array。

3.遍历原数组，把原数组每一个元素插入到新数组Array对应的位置，比如元素的值为n，则插入到Array[n-min]当中。此时Array的部分位置为空，部分位置填充了数值。

4.遍历新数组Array，统计出Array中最大连续出现空值的次数+1，即为相邻元素最大差值。

### 如何查找一个单项链表的倒数第k个节点

1、先将链表遍历一次，求出链表的长度，之后再进行查找，找出第n-k个节点就是倒数第k个节点。

2、设置一个指针，一次向后移动k次，如果最后一次指向空节点，说明链表已经结束，那么第一次指向的节点就是倒数第k个节点。

3、设置两个指针，中间差k-1，当第一个节点移动到末尾时，第二个节点指向的就是倒数第k个节点。

