* [内排序和外排序](#%E5%86%85%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A4%96%E6%8E%92%E5%BA%8F)
  * [内排序](#%E5%86%85%E6%8E%92%E5%BA%8F)
    * [分类](#%E5%88%86%E7%B1%BB)
      * [选择排序](#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)
      * [冒泡排序](#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)
        * [优化](#%E4%BC%98%E5%8C%96)
      * [鸡尾酒排序](#%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F)
      * [插入排序](#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)
      * [希尔排序](#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)
      * [归并排序](#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)
      * [快速排序](#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)
        * [优化](#%E4%BC%98%E5%8C%96-1)
        * [JDK1\.7中的快排](#jdk17%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8E%92)
      * [堆排序](#%E5%A0%86%E6%8E%92%E5%BA%8F)
        * [算法步骤](#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4)
      * [计数排序](#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F)
        * [局限](#%E5%B1%80%E9%99%90)
      * [桶排序](#%E6%A1%B6%E6%8E%92%E5%BA%8F)
    * [适用场景](#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF)
    * [比较](#%E6%AF%94%E8%BE%83)
* [海量数据排序](#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F)

# 内排序和外排序

**概念**

内部排序：待排序记录存放在计算机随机存储器中（说简单点，就是内存）进行的排序过程。

外部排序：待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程。

从概念我们可以清晰的看到二者的区别

**衡量效率的方法**

内部排序：比较次数，也就是时间复杂度

外部排序：IO次数，也就是读写外存的次数

**方法**

排序方法
内部排序：插入排序、快速排序、选择排序、归并排序、基数排序等

外部排序：

先来了解下外部排序的过程吧。

外部排序基本上由两个相对独立的阶段组成。首先，按可用内存大小，将外存上含n个记录的文件分成若干长度为l的子文件或段，依次读入内存并利用有效的内部排序方法对他们进行排序，并将排序后得到的有序子文件重新写入外存，通常称这些有序子文件为归并段；然后，对这些归并段进行逐趟归并，使归并段逐渐由小至大，直至得到整个有序文件为止。

好了，读了上面这段文字之后，我们可以知道，第一阶段就是内部排序，这个我们都知道怎么做，那么第二阶段呢？也就是归并的过程是怎么实现的，常用的有两种方法，一，多路平衡归并；二，置换-选择排序

**算法稳定性**

假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！

## 内排序

### 分类

#### 选择排序

原理：每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。

```java
public class SelectionSort {
    public static void main(String[] args) {
        int[] arr={1,3,2,45,65,33,12};
        System.out.println("交换之前：");
        for(int num:arr){
            System.out.print(num+" ");
        }        
        //选择排序的优化
        for(int i = 0; i < arr.length - 1; i++) {// 做第i趟排序
            int k = i;
            for(int j = k + 1; j < arr.length; j++){// 选最小的记录
                if(arr[j] < arr[k]){ 
                    k = j; //记下目前找到的最小值所在的位置
                }
            }
            //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换
            if(i != k){  //交换a[i]和a[k]
                int temp = arr[i];
                arr[i] = arr[k];
                arr[k] = temp;
            }    
        }
        System.out.println();
        System.out.println("交换后：");
        for(int num:arr){
            System.out.print(num+" ");
        }
    }

}
```

#### 冒泡排序

```java
    private static void bubbleSort(int[] a) {
        for (int i = 1; i < a.length; i++) {
            for (int j = 0; j < a.length - i; j++) {
                if (a[j] > a[j + 1]) {
                    int tem = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = tem;
                }
            }
        }
    }
```

##### 优化

```java
    public void bubbleSort(Integer[] arr, int n) {
        if (n <= 1) return;       //如果只有一个元素就不用排序了
 
        for (int i = 0; i < n; ++i) {
            // 提前退出冒泡循环的标志位,即一次比较中没有交换任何元素，这个数组就已经是有序的了
            boolean flag = false;
            for (int j = 0; j < n - i - 1; ++j) {        //此处你可能会疑问的j<n-i-1，因为冒泡是把每轮循环中较大的数飘到后面，
                // 数组下标又是从0开始的，i下标后面已经排序的个数就得多减1，总结就是i增多少，j的循环位置减多少
                if (arr[j] > arr[j + 1]) {        //即这两个相邻的数是逆序的，交换
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    flag = true;
                }
            }
            if (!flag) break;//没有数据交换，数组已经有序，退出排序
        }
    }
```



#### 鸡尾酒排序

冒泡排序的每一个元素都可以像小气泡一样，根据自身大小，一点一点向着数组的一侧移动。算法的每一轮从都是**从左到右比较元素，进行单向的位置交换**。

那么鸡尾酒排序做了怎样的优化呢？

鸡尾酒排序的元素比较和交换过程是**双向**的。

排序过程就像钟摆一样，第一轮从左到右，第二轮从右到左，第三轮再从左到右......

```java
    private static void sort(int array[]) {
        int tmp = 0;
        for (int i = 0; i < array.length / 2; i++) {
//有序标记，每一轮的初始是true
            boolean isSorted = true;
//奇数轮，从左向右比较和交换
            for (int j = i; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    tmp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = tmp;
//有元素交换，所以不是有序，标记变为false
                    isSorted = false;
                }
            }
            if (isSorted) {
                break;
            }
            //偶数轮之前，重新标记为true
            isSorted = true;
//偶数轮，从右向左比较和交换
            for (int j = array.length - i - 1; j > i; j--) {
                if (array[j] < array[j - 1]) {
                    tmp = array[j];
                    array[j] = array[j - 1];
                    array[j - 1] = tmp;
//有元素交换，所以不是有序，标记变为false
                    isSorted = false;
                }
            }
            if (isSorted) {
                break;
            }
        }
    }
```



#### 插入排序

插入排序的基本思想就是将无序序列插入到有序序列中。

```java
 //插入排序
    private static void insertSort(int[] a) {
        for (int i = 1; i < a.length; i++) {
            int currentNum = a[i];
            int j;
            for (j = i - 1; j >= 0; j--) {
                if (currentNum < a[j]) {
                    a[j + 1] = a[j];
                } else {
                    break;
                }
            }
            a[j + 1] = currentNum;
        }
    }
```



#### 希尔排序

希尔排序(Shell's Sort)在插入排序算法的基础上进行了改进，算法的时间复杂度与前面几种算法相比有较大的改进。其算法的基本思想是：先将待排记录序列分割成为若干子序列分别进行插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行一次直接插入排序。

```java
public static void shellSort(int[] a){
		int N = a.length;
		
		for(int h = N / 2; h > 0; h /= 2){//希尔增量
			for(int i = h; i < N; i++){
				//将a[i]插入到a[i-h],a[i-2h],a[i-3h]...中
				for(int j = i; j >= h && a[j] < a[j - h]; j -= h){
					int temp = a[j];
					a[j] = a[j-h];
					a[j-h] = temp;
				}
			}
		}
	}
```

#### 归并排序

采用分治法的思想

“归并”的含义是将两个或两个以上的有序序列组合成一个新的有序表。假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到（表示不小于x的最小整数）个长度为2(或者是1)的有序子序列，再两两归并。如此重复，直到得到一个长度为n的有序序列为止。这种排序方法称为2-路归并排序。

```java
  private static void mergeSort(int[] array, int low, int high) {
    int middle = (low + high) / 2;
    if (low < high) {
        mergeSort(array, low, middle);
        mergeSort(array, middle + 1, high);
        merge(array, low, middle, high);
    }
}

/**
 * 将low-midlle 和 middle - high的数进行合并
 * @param array
 * @param low
 * @param middle
 * @param high
 */
private static void merge(int[] array, int low, int middle, int high) {
    int[] ans = new int[high - low + 1];
    int i = low;
    int j = middle + 1;
    int k = 0;
    while (i <= middle && j <= high) {
        if (array[i] < array[j]) {
            ans[k++] = array[i++];
        } else {
            ans[k++] = array[j++];
        }
    }
    while (i <= middle) {
        ans[k++] = array[i++];
    }
    while (j <= high) {
        ans[k++] = array[j++];
    }
    for (int x = 0; x < ans.length; x++) {
        array[x + low] = ans[x];
    }
}
```



#### 快速排序

##### 优化

对快速排序算法的另一种改进就是使用一个尽可能再文件中间划分为元素，即基准值key的大小最好是在待排序文件中不大不小

有以两种思路：

·一种是避免最坏的情况，使用数组中的一个随机元素作为划分元素，这样出现最坏情况的几率就会相对很小

·一种是从文件中取出三个元素，使用三个元素的中间元素作为划分元素

```java
    private static void quickSort(int[] a, int low, int high) {
        if (low > high) return;
        int i = low;
        int j = high;
        int stand = a[low];
        while (i < j) {
            while (i < j) {
                if (a[j] < stand) {
                    break;
                }
                j--;
            }
            while (i < j) {
                if (a[i] > stand) {
                    break;
                }
                i++;
            }
            if (i < j) {
                int t = a[i];
                a[i] = a[j];
                a[j] = t;
            }
        }
        //快速排序是一个不稳定的排序算法，不稳定发生在中枢元素a[low]和a[j]交换的时刻
        a[low] = a[i];
        a[i] = stand;
        quickSort(a, low, i - 1);
        quickSort(a, i + 1, high);
    }
```

##### JDK1.7中的快排

1.需要排序的数组为a,判断数组的长度是否大于286，大于使用归并排序（merge sort），否则执行2。 
2.判断数组长度是否小于47，小于则采用插入排序，否则执行3。 
3.采用近似算法计算数组长度的1/7

> int seventh = (length >> 3) + (length >> 6) + 1; 

4.取出5个点

> int e3 = (left + right) >>> 1; // 中位数 
>
> int e2 = e3 - seventh; 
>
> int e1 = e2 - seventh; 
>
> int e4 = e3 + seventh;
>
> int e5 = e4 + seventh; 

5.将这5个元素进行插入排序 
6.选取a[e2],a[e4]分别作为pivot1，pivot2。由于步骤5进行了排序，所以必有pivot1 < pivot2。 
7.接下来定义3个指针，分别是less,k,great。先说一下**最终结果，less和great将数组分为3个部分，分别是小于less的，大于less小于great的元素和大于great的元素。** 
如何达到这个结果呢，初始时，less和great分别指向数组起始的元素和结束的元素。此时，所有的元素在less和great之间，即待处理的元素。随着程序的进行，小于less的元素逐步移动到less左边，大于great的元素移动到great右边。 
另外有一个指针k表示处理到哪个元素了，初始值为less，结束值为great（这里的great是会动态改变的，但是大于great的元素一定是处理过的） 

8.将a[k]分别与pivot1，pivot2比较。如果小于pivot1，则将a[k]与a[less]对调，同时k++。如果大于pivot2，则执行9；否则执行10。 
9.将a[great]分别与pivot1，pivot2比较。如果a[great]大于pivot2，则递减great，直到大于pivot2的条件不满足或者k==great。如果a[great]小于pivot1，则将a[great]换到小于less的区域。如果a[great]大于pivot1，则说明位于中间区域，将a[great]与a[k]对调。great–。 
10.k++，如果k>great,说明处理完成，则执行11，否则继续执行8； 
11.由于前面的操作，还未将pivot1，pivot2这2个元素放对位置，所以还需要将a[less - 1]移动到队头，pivot1移动到（less - 1）的位置，将a[great +1]移动到队尾，pivot2移动到（great +1）的位置。 
12.至此，已经达到步骤7描述的最终结果，将数组分为了3个区域。对较小的区域和较大的区域递归执行步骤2。判断中间的区域是否过大，如果是，则执行13，否则递归执行步骤2。 
13.将等于pivot1或者pivot2的元素移动到两边，然后递归执行步骤2。

#### 堆排序

##### 算法步骤

1. 创建一个堆 H[0……n-1]；
2. 把堆首（最大值）和堆尾互换；
3. 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；
4. 重复步骤 2，直到堆的尺寸为 1。

```java
package test;

import java.util.Arrays;

public class HeapSort {

    private int[] A;
    private int heapsize;

    private int parent(int i) {
        return (i - 1) / 2;
    }

    private int left(int i) {
        return 2 * i + 1;
    }

    private int right(int i) {
        return 2 * i + 2;
    }

    //将大数往下沉
    private void maxHeapify(int i) {
        int l = left(i);
        int r = right(i);
        int largest = i;
        if (l <= heapsize - 1 && A[l] > A[i]) {
            largest = l;
        }
        if (r <= heapsize - 1 && A[r] > A[largest]) {
            largest = r;
        }
        if (largest != i) {
            int temp = A[i];
            A[i] = A[largest];
            A[largest] = temp;
            this.maxHeapify(largest);
        }
    }

    //构建最大堆
    private void buildMaxHeap(int[] A) {
        this.A = A;
        this.heapsize = A.length;

        for (int i = parent(heapsize - 1); i >= 0; i--) {
            maxHeapify(i);
        }
    }

    private void heapSort(int[] A) {
        buildMaxHeap(A);
        for (int i = A.length - 1; i >= 0; i--) {
            int t = A[i];
            A[i] = A[0];
            A[0] = t;
            heapsize--;
            maxHeapify(0);
        }
    }

    public static void main(String[] args) {
        int[] A = {3, 7, 2, 11, 3, 4, 9, 2, 18, 0};
        HeapSort dEmo = new HeapSort();
        dEmo.heapSort(A);
        Arrays.stream(A).forEach(System.out::println);
    }
}
```

#### 计数排序

![](C:/Users/zhouguo_sx/Desktop/interview_pub/pic/%E7%88%B1%E5%A5%87%E8%89%BA20190708145213.png)

假定20个随机整数的值如下：

**9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9 ，7，9**

如何给这些无序的随机整数排序呢？

非常简单，让我们遍历这个无序的随机数列，每一个整数按照其值对号入座，对应数组下标的元素进行加1操作。

比如第一个整数是9，那么数组下标为9的元素加1：

![img](http://5b0988e595225.cdn.sohucs.com/images/20181008/7cf7fe2633a041fd8e3c37679b2bc5df.png)

第二个整数是3，那么数组下标为3的元素加1：

![img](http://5b0988e595225.cdn.sohucs.com/images/20181008/a10d6ad473d94bfe917f056ea4a27b66.png)

继续遍历数列并修改数组......

最终，数列遍历完毕时，数组的状态如下：

![img](http://5b0988e595225.cdn.sohucs.com/images/20181008/a189188a95b640ac89d547d3ce3e3187.png)

数组每一个下标位置的值，代表了数列中对应整数出现的次数。

有了这个“统计结果”，排序就很简单了。直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次：

**0，1，1，2，3，3，3，4，4，5，5，6，7，7，8，9，9，9，9，10**

显然，这个输出的数列已经是有序的了。

##### 局限

**1.当数列最大最小值差距过大时，并不适用计数排序。**

**2.当数列元素不是整数，并不适用计数排序。**

```java
import java.util.*;
public class CountingSort {
    public int[] countingSort(int[] A, int n) {
        countingSort(A);
        return A;
    }
    public void countingSort(int[] arr) {
        int[] tempArr = new int[arr.length];// 临时数组
        int[] timesArr;// 统计每个元素出现的次数，放入到对应的桶中
        int range;// 统计这一组的范围，得出需要多少个桶
        int max = arr[0];
        int min = arr[0];
        for (int a : arr) {
            if (a > max)
                max = a;
            if (a < min)
                min = a;
        }
        range = max - min + 1;// 得出极值差，为了减小临时数组(统计各元素出现的次数)的长度
        timesArr = new int[range];
        for (int i = 0; i < arr.length; i++) {
            timesArr[arr[i] - min]++;
        }
        for (int i = 1; i < timesArr.length; i++) {// 得到所有元素的大小上的总体顺序
            timesArr[i] += timesArr[i - 1];
        }
        for (int i = 0; i < arr.length; i++) {// 将arr中元素的位置顺序对应到临时数组中
            int position = timesArr[arr[i] - min];// 得到arr[i]这个元素在整体上的位置
            tempArr[--position] = arr[i];// 根据上面的位置，将该元素放入到临时数组中
            timesArr[arr[i] - min]--;
        }
        for (int i = 0; i < arr.length; i++) {
            arr[i] = tempArr[i];
        }
    }
}
```

#### 桶排序

![](..\pic\爱奇艺20190805161519.png)

![](..\pic\爱奇艺20190805161549.png)





![](..\pic\爱奇艺20190805161411.png)





### 适用场景

1. 若n**较小**(如n≤50)，可采用直接插入或直接选择排序。

​	当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。

2. 若文件初始状态**基本有序**(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；

3. 若n**较大**，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。

​	快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
​    堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。
​    若要求排序稳定，则可选用归并排序。但本章介绍的从单个记录起进行两两归并的  排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定 的，所以改进后的归并排序仍是稳定的。

### 比较

| 类别     | 排序方法 | 时间复杂度 | 空间复杂度 | 稳定   |
| :------- | -------- | ---------- | ---------- | ------ |
| 插入排序 | 直接插入 | O(n2)      | O(1)       | 稳定   |
| 插入排序 | 希尔排序 | O(n1.3-2)  | O(1)       | 不稳定 |
| 选择排序 | 直接选择 | O(n2)      | O(1)       | 不稳定 |
| 选择排序 | 堆排序   | O(nlogn)   | O(1)       | 不稳定 |
| 交换排序 | 冒泡排序 | O(n2)      | O(1)       | 稳定   |
| 交换排序 | 快速排序 | O(nlogn)   | O(nlogn)   | 不稳定 |
| 归并排序 |          | O(nlogn)   | O(n)       | 稳定   |

# 海量数据排序

今天要给100亿个数字排序，100亿个 int 型数字放在文件里面大概有 37.2GB，非常大，内存一次装不下了。那么肯定是要拆分成小的文件一个一个来处理，最终在合并成一个排好序的大文件。

实现思路

1.把这个37GB的大文件，用哈希分成1000个小文件，每个小文件平均38MB左右（理想情况），把100亿个数字对1000取模，模出来的结果在0到999之间，每个结果对应一个文件，所以我这里取的哈希函数是 h = x % 1000，哈希函数取得”好”，能使冲突减小，结果分布均匀。

2.拆分完了之后，得到一些几十MB的小文件，那么就可以放进内存里排序了，可以用快速排序，归并排序，堆排序等等。

3.1000个小文件内部排好序之后，就要把这些内部有序的小文件，合并成一个大的文件，可以用二叉堆来做1000路合并的操作，每个小文件是一路，合并后的大文件仍然有序。

首先遍历1000个文件，每个文件里面取第一个数字，组成 (数字, 文件号) 这样的组合加入到堆里（假设是从小到大排序，用小顶堆），遍历完后堆里有1000个 (数字，文件号) 这样的元素
然后不断从堆顶拿元素出来，每拿出一个元素，把它的文件号读取出来，然后去对应的文件里，加一个元素进入堆，直到那个文件被读取完。拿出来的元素当然追加到最终结果的文件里。