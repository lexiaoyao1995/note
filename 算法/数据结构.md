# 树的种类

#### 无序树

树的任意节点的子节点没有顺序关系。

#### 有序树

树的任意节点的子节点有顺序关系。

#### 二叉树

树的任意节点至多包含两棵子树。

#### 满二叉树

叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。

#### 完全二叉树

对于一颗二叉树，假设其深度为d（d>1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树； 
PS：这里的满二叉树和完全二叉树取的是国内的定义，国外的定义不一样，有兴趣的可以去看看国外的定义。

#### 平衡二叉树（AVL）

它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。

#### 二叉查找树（二叉搜索树、BST）

若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 
若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 
任意节点的左、右子树也分别为二叉查找树； 
没有键值相等的节点。

#### 霍夫曼树

带权路径最短的二叉树称为哈夫曼树或最优二叉树。

#### 红黑树

红黑树是一颗特殊的二叉查找树，除了二叉查找树的要求外，它还具有以下特性：

> 每个节点或者是黑色，或者是红色。
> 根节点是黑色。
> 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
> 如果一个节点是红色的，则它的子节点必须是黑色的。
> 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

#### B-tree（B-树或者B树）

一颗m阶B树的特性：

根结点至少有两个子女（如果B树只有一个根节点，这个根节点的key的数量可以为[1~m-1]）
每个非根节点所包含的关键字个数 j 满足：⌈m/2⌉ - 1 <= j <= m - 1，节点的值按非降序方式存放，即从左到右依次增加
除根结点以及叶子节点以外的所有结点的度数正好是关键字总数加1，故内部节点的子树个数 k 满足：⌈m/2⌉ <= k <= m
所有的叶子结点都位于同一层

#### B+树

m阶B+树是m阶B-tree的变体，它的定义大致跟B-tree一致，不过有以下几点不同：

有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点，其中⌈m/2⌉ <= n <= m
所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接
所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字
通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点

# 链表

### 跳跃表

跳跃表是一种基于有序链表的扩展，类似与索引的思路，可以更快查找到一个有序链表的某一个节点。

![](C:/Users/zhouguo_sx/Desktop/interview_pub/pic/%E7%88%B1%E5%A5%87%E8%89%BA20190708150721.png)

选取索引的规则：

采取抛硬币的方法，随机决定，大体保证索引分布均匀。

##### 和二叉树的区别

![](C:/Users/zhouguo_sx/Desktop/interview_pub/pic/%E7%88%B1%E5%A5%87%E8%89%BA20190708150931.png)



# 数组和链表的区别

##### **我们知道遍历数组和链表的时间复杂度是O(n),但是在实际中确实数组的速度要比链表快，这是为什么呢？**

1.首先，数组是具有相同的数据类型且按一定次序排列的一组变量的集合体，构成一个数组的这些变量称为数组元素，数组在内存中的地址是连续相邻的，而链表在内存的地址是散列的，不连续的

2. CPU缓存会把一片连续的内存空间读入， 因为数组结构是连续的内存地址， 所以数组全部或者部分元素被连续存在CPU缓存里面，而链表的节点是分散在堆空间里面的，这时候CPU缓存帮不上忙，只能是去读取内存，而缓存的速率要比内存快。
3. CPU --》寄存器--》缓存 --》内存

cpu 取数据，处理数据，都要放到寄存器中处理（存放指令），缓存就是吧内存中提取的数据暂时保存在里面。
        
如果寄存器要获取内存中同一位置的数据，就从缓存中获取，如果寄存器获取的不是同一个内存地址的数据（或者获取的内存地址缓存中不存在），就从内存中查找获取 
从上述比较中，我们可以看出数组的查询，要比链表的快

##### 插入和删除的操作比较：

1.数组的中间插入（或删除）一个元素，那么这个元素后的所有元素的内存地址都要往后（前）移动（数组的内存地址是连续的），对最后一个元素插入（或删除）时才比较快，而链表不需要改变内存的地址，只需要修改节点的信息即可（包括指针指向，节点值）。

2.链表的扩展性较好，定义数组时所占用的空间大小都是固定的，如果存储满了，无法扩展，只能新建一个更大空间的数组。

综上所述我们可以得出：

数组大小固定，不适合动态存储，动态添加，内存为一连续的地址，可随机访问，查询较快，

而链表大小可变，扩展性强，只能顺着指针的方向查询，速度较慢。



**为什么寄存器比内存快？**

1.距离不同 。

寄存器在CPU内部，当然读起来会快一点，内存在外部的内存插槽内，要电流经过电路板进行传输

2.硬件设计不同

3.工作方式不同

寄存器就是找到相应的位，然后读取这些位，两步操作。
而内存则复杂的多

（1）找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。
（2）将指针送往内存管理单元（MMU），由MMU将虚拟的内存地址翻译成实际的物理地址。
（3）将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。
（4）确定数据在哪一个内存块（chunk）上，从该块读取数据。
（5）数据先送回内存控制器，再送回CPU，然后开始使用。
内存的工作流程比寄存器多出许多步。每一步都会产生延迟，累积起来就使得内存比寄存器慢得多。

