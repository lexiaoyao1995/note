[TOC]
* [TCP](#tcp)
  * [TCP整体介绍](#tcp%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D)
  * [三次握手](#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
    * [为什么不是四次和两次](#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1%E5%92%8C%E4%B8%A4%E6%AC%A1)
        * [不是四次的原因](#%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1%E7%9A%84%E5%8E%9F%E5%9B%A0)
        * [不是两次的原因](#%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%8E%9F%E5%9B%A0)
    * [syn洪水攻击发生原因](#syn%E6%B4%AA%E6%B0%B4%E6%94%BB%E5%87%BB%E5%8F%91%E7%94%9F%E5%8E%9F%E5%9B%A0)
  * [四次挥手](#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
    * [为什么需要等待2MSL后才能关闭链接](#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%852msl%E5%90%8E%E6%89%8D%E8%83%BD%E5%85%B3%E9%97%AD%E9%93%BE%E6%8E%A5)
  * [Keepalive](#keepalive)
  * [滑动窗口](#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3)
  * [Nagel算法与ACK延迟](#nagel%E7%AE%97%E6%B3%95%E4%B8%8Eack%E5%BB%B6%E8%BF%9F)
  * [拥塞控制](#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)
  * [TCP状态转化](#tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96)
* [UDP](#udp)
  * [应用场景](#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)
  * [分类](#%E5%88%86%E7%B1%BB)
* [TCP和UDP区别](#tcp%E5%92%8Cudp%E5%8C%BA%E5%88%AB)


# TCP

## TCP整体介绍

tcp是传输层协议，对应osi网络模型的传输层第四层；

基于链接，传输数据前需要先建立好链接，然后再进行数据传输，tcp链接一旦建立，就可以进行 双向通信；

tcp的传输是基于字节流而不是报文，将数据按照字节大小进行编号，接收端通过ack来确认收到的数据编号，通过这种机制保证接受数据的有序性和完整性，因此tcp能够提供可靠性传输

tcp还能提供流量控制，通过滑动窗口来控制数据的发送速率，

> 该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量。

滑动窗口的本质是动态缓冲区，接收端根据自己的处理能力在tcp的header中动态调整窗口大小，通过ack应答包通知给发送端，发送端通过窗口的大小调整发送的速度

tcp考虑到处理网络问题导致大量重传导致网络恶化，tcp提供了拥塞控制，防止过多的数据注入到网络当中，这样可以使网络中的路由器或链路不致过载。主要用到了慢启动，拥塞避免，快启动，快速回复，四个算法。

> **TCP通过一个定时器（timer）采样了RTT并计算RTO(Retransmission TimeOut 重传超时时间)，但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，然而重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包**，这就导致了恶性循环，最终形成“网络风暴” —— TCP的拥塞控制机制就是用于应对这种情况。 
>
> (RTT(Round Trip Time)由三部分组成：链路的传播时间（propagation delay),末端系统的处理时间，路由器缓存中的排队和处理时间（queuing delay）。)
>
> **为了在发送端调节所要发送的数据量，定义了一个“拥塞窗口”（Congestion Window），在发送数据时，将拥塞窗口的大小与接收端ack的窗口大小做比较，取较小者作为发送数据量的上限。**
>
> 1.慢启动：意思是刚刚加入网络的连接，一点一点地提速，不要一上来就把路占满。 
> 连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。 
> 每当收到一个ACK，cwnd++; 呈线性上升 
> 每当过了一个RTT，cwnd = cwnd*2; 呈指数让升 
> 阈值ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法” 
> 2.拥塞避免：当拥塞窗口 cwnd 达到一个阈值时，窗口大小不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞。 
> 每当收到一个ACK，cwnd = cwnd + 1/cwnd 
> 每当过了一个RTT，cwnd = cwnd + 1 
> 拥塞发生：当发生丢包进行数据包重传时，表示网络已经拥塞。分两种情况进行处理： 
> 等到RTO超时，重传数据包 
> sshthresh = cwnd /2 
> cwnd 重置为 1 
> 3.进入慢启动过程 
> 在收到3个duplicate ACK时就开启重传，而不用等到RTO超时 
> sshthresh = cwnd = cwnd /2 
> 进入快速恢复算法——Fast Recovery 
> 4.快速恢复：至少收到了3个Duplicated Acks，说明网络也不那么糟糕，可以快速恢复。 
> cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了） 
> 重传Duplicated ACKs指定的数据包 
> 如果再收到 duplicated Acks，那么cwnd = cwnd +1 
> 如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了

## 三次握手

![](../pic/爱奇艺20190704152430.png)

### 为什么不是四次和两次

##### 不是四次的原因

Server段的SYN和ACK合并为一次发送，断开链接时，两个方向的数据，发送的停止时间可能是不同的，所以无法合并fin和ack发送

##### 不是两次的原因

为了实现可靠传输，发送方和接收方始终需要同步( SYNchronize )序号。 需要注意的是， 序号并不是从 0 开始的， 而是由发送方随机选择的初始序列号 ( Initial Sequence Number, ISN )开始 。 由于 TCP 是一个双向通信协议， 通信双方都有能力发送信息， 并接收响应。 因此， 通信双方都需要随机产生一个初始的序列号， 并且把这个起始值告诉对方。
于是， 这个过程就变成了下面这样。

### syn洪水攻击发生原因

server端收到client端的链接请求后，发送了SYN和ACK，但是Client端不进行回复，导致Server端大量链接处在SYN_RCVD状态，进而影响其他正常请求的建连

可以通过设置linux的参数SYN_ACK_reTrys =0 来加快半链接的回收速度

## 四次挥手

![](../pic/%E7%88%B1%E5%A5%87%E8%89%BA20190704153415.png)

msl最大报文段生存时间

client端收到fin后，向Server发送ack，进入time_wait状态，等待2MSL后进入closed状态

### 为什么需要等待2MSL后才能关闭链接

1、保证tcp协议的全双工链接能够有效关闭

2、保证这次链接中，重复的数据段能够从网络中消失，防止端口被重用的时候，可能会产生数据混淆

Nagel算法与ACK延迟

解决小包问题，提高数据载荷比，对延迟比较敏感且发送频率较低的场景可以关闭nagel算法

特定情况下，nagel和ack延迟机制配合使用，可能出现延迟超时后才能回复ack包的问题

> \1. Nagle算法：
>
> 是为了减少广域网的小分组数目，从而减小网络拥塞的出现；
>
> 该算法要求一个tcp连接上最多只能有一个未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组，tcp需要收集这些少量的分组，并在ack到来时以一个分组的方式发送出去；其中小分组的定义是小于MSS的任何分组；
>
> 该算法的优越之处在于它是自适应的，确认到达的越快，数据也就发哦送的越快；而在希望减少微小分组数目的低速广域网上，则会发送更少的分组；
>
> 
>
> \2. 延迟ACK：
>
> 如果tcp对每个数据包都发送一个ack确认，那么只是一个单独的数据包为了发送一个ack代价比较高，所以tcp会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ack，如果在延迟ack定时器触发时候，发现ack尚未发送，则立即单独发送；
>
> 延迟ACK好处：
>
> (1) 避免糊涂窗口综合症；
>
> 当发送端应用进程产生数据很慢、或接收端应用进程处理接收缓冲区数据很慢，或二者兼而有之；就会使应用进程间传送的报文段很小，特别是有效载荷很小。 极端情况下，有效载荷可能只有1个字节；而传输开销有40字节(20字节的IP头+20字节的TCP头) 这种现象就叫糊涂窗口综合症
>
> (2) 发送数据的时候将ack捎带发送，不必单独发送ack；
>
> (3) 如果延迟时间内有多个数据段到达，那么允许协议栈发送一个ack确认多个报文段；

## Keepalive

长时间没有数据发送的场景下，tcp保持长期可用的机制

## 滑动窗口

tcp提供流量控制，通过滑动窗口来控制数据的发送速率，

该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量。

滑动窗口的本质是动态缓冲区，接收端根据自己的处理能力在tcp的header中动态调整窗口大小，通过ack应答包通知给发送端，发送端通过窗口的大小调整发送的速度

## Nagel算法与ACK延迟

解决小包问题，提高数据载荷比，对延迟比较敏感且发送频率较低的场景可以关闭nagel算法

特定情况下，nagel和ack延迟机制配合使用，可能出现延迟超时后才能回复ack包的问题

> \1. Nagle算法：
>
> 是为了减少广域网的小分组数目，从而减小网络拥塞的出现；
>
> 该算法要求一个tcp连接上最多只能有一个未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组，tcp需要收集这些少量的分组，并在ack到来时以一个分组的方式发送出去；其中小分组的定义是小于MSS的任何分组；
>
> 该算法的优越之处在于它是自适应的，确认到达的越快，数据也就发哦送的越快；而在希望减少微小分组数目的低速广域网上，则会发送更少的分组；
>
> 
>
> \2. 延迟ACK：
>
> 如果tcp对每个数据包都发送一个ack确认，那么只是一个单独的数据包为了发送一个ack代价比较高，所以tcp会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ack，如果在延迟ack定时器触发时候，发现ack尚未发送，则立即单独发送；
>
> 延迟ACK好处：
>
> (1) 避免糊涂窗口综合症；
>
> 当发送端应用进程产生数据很慢、或接收端应用进程处理接收缓冲区数据很慢，或二者兼而有之；就会使应用进程间传送的报文段很小，特别是有效载荷很小。 极端情况下，有效载荷可能只有1个字节；而传输开销有40字节(20字节的IP头+20字节的TCP头) 这种现象就叫糊涂窗口综合症
>
> (2) 发送数据的时候将ack捎带发送，不必单独发送ack；
>
> (3) 如果延迟时间内有多个数据段到达，那么允许协议栈发送一个ack确认多个报文段；

## 拥塞控制

tcp考虑到处理网络问题导致大量重传导致网络恶化，tcp提供了拥塞控制，防止过多的数据注入到网络当中，这样可以使网络中的路由器或链路不致过载。主要用到了慢启动，拥塞避免，快启动，快速回复，四个算法。

> **TCP通过一个定时器（timer）采样了RTT并计算RTO(Retransmission TimeOut 重传超时时间)，但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，然而重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包**，这就导致了恶性循环，最终形成“网络风暴” —— TCP的拥塞控制机制就是用于应对这种情况。 
>
> (RTT(Round Trip Time)由三部分组成：链路的传播时间（propagation delay),末端系统的处理时间，路由器缓存中的排队和处理时间（queuing delay）。)
>
> **为了在发送端调节所要发送的数据量，定义了一个“拥塞窗口”（Congestion Window），在发送数据时，将拥塞窗口的大小与接收端ack的窗口大小做比较，取较小者作为发送数据量的上限。**
>
> 1.慢启动：意思是刚刚加入网络的连接，一点一点地提速，不要一上来就把路占满。 
> 连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。 
> 每当收到一个ACK，cwnd++; 呈线性上升 
> 每当过了一个RTT，cwnd = cwnd*2; 呈指数让升 
> 阈值ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法” 
> 2.拥塞避免：当拥塞窗口 cwnd 达到一个阈值时，窗口大小不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞。 
> 每当收到一个ACK，cwnd = cwnd + 1/cwnd 
> 每当过了一个RTT，cwnd = cwnd + 1 
> 拥塞发生：当发生丢包进行数据包重传时，表示网络已经拥塞。分两种情况进行处理： 
> 等到RTO超时，重传数据包 
> sshthresh = cwnd /2 
> cwnd 重置为 1 
> 3.进入慢启动过程 
> 在收到3个duplicate ACK时就开启重传，而不用等到RTO超时 
> sshthresh = cwnd = cwnd /2 
> 进入快速恢复算法——Fast Recovery 
> 4.快速恢复：至少收到了3个Duplicated Acks，说明网络也不那么糟糕，可以快速恢复。 
> cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了） 
> 重传Duplicated ACKs指定的数据包 
> 如果再收到 duplicated Acks，那么cwnd = cwnd +1 
> 如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了

## TCP状态转化

![](../pic/爱奇艺20190725144717.png)

客户端独有的：（1）SYN_SENT （2）FIN_WAIT1 （3）FIN_WAIT2 （4）CLOSING （5）TIME_WAIT 。

服务器独有的：（1）LISTEN （2）SYN_RCVD （3）CLOSE_WAIT （4）LAST_ACK 。

共有的：（1）CLOSED （2）ESTABLISHED 。

# UDP

UDP是User Datagram Protocol的简称，中文名是用户数据报协议，是OSI参考模型中的传输层协议，它是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 

## 应用场景

由于缺乏可靠性且属于非连接导向协议，UDP的应用一般必须允许一定量的丢包、出错和复制粘贴。但有些应用，比如TFTP，需要可靠性保证，则必须在应用层增加根本的可靠机制。但是绝大多数UDP应用都不需要可靠机制，甚至可能因为引入可靠机制而降低性能。流媒体、即时多媒体游戏和IP电话（VoIP）就是典型的UDP应用。如果某个应用需要很高的可靠性，那么可以用传输控制协议（即TCP协议）来代替UDP。

使用UDP协议的应用有：域名系统（DNS）、简单网络管理协议（SNMP）、动态主机配置协议（DHCP）、路由信息协议（RIP）等等。因为UDP不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失几个数据包，也不会对接收结果产生太大影响。

## 分类

单播、多播、广播、组播

> 1 -> 1 就是单播；
> 1 -> M 就是多播；
> 1 -> A 就是广播；
> 1 -> G 就是组播；
> 当M=A时，多播就是广播；
> 当M=G时，多播就是组播；

# TCP和UDP区别

| 特征点     | TCP          | UDP            |
| ---------- | ------------ | -------------- |
| 是否连接   | 面向连接     | 面向非连接     |
| 传输可靠性 | 可靠         | 会丢包，不可靠 |
| 应用场景   | 传输数据量大 | 传输量小       |
| 速度       | 慢           | 快             |